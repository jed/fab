<!DOCTYPE HTML> <html>   <head>     <meta http-equiv='content-type' content='text/html;charset=UTF-8' />     <title>(fab) - a pure javascript DSL for building async web apps</title>      <script src="sh_javascript.min.js"></script>     <script src="sh_main.min.js"></script>      <link rel="stylesheet" type="text/css" href="sh_ide-codewarrior.min.css"/>     <style>       h1 {         background: url(logo.png) 50% 50% no-repeat;         height: 129px;         margin: 0;         text-indent: 9999px;         overflow: hidden;       }              h2 {         text-align: center;             margin-bottom: 30px;         font-family: "Georgia", "Times New Roman", serif;       }            body {         font: 13.34px Helvetica, Arial, sans-serif;       }              code {         font-size: 16px;       }              #container {         line-height: 1.5em;         font-size: 110%;         text-align: justify;         width: 40em;         margin: 20px auto;       }              pre {         background-color: #F8F8FF !important;         border: 1px solid #D9D9D9 !important;         padding: .5em !important;       }     </style>   </head>   <body onload="sh_highlightDocument();">    <a href="http://github.com/jed/fab"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub" /></a>    <div id='container'>      <h1>(fab)</h1>     <h2>a pure javascript DSL for building async web apps</h2>          <h3 id="intro">Introduction</h3>          <p>       (fab) is a lightweight (~2KB minified and gzipped) toolkit that makes it easy to build asynchronous web apps. It takes advantage of the flexibility of javascript to create a concise DSL without pre-compilation or magic scope hackery.     </p>          <p>       Here's an example of an application running on <a href="http://nodejs.org">node.js</a> (currently the only supported platform). Just create a file like this:     </p>          <pre class="sh_javascript">( fab )
  ( "/hello", "hello!" )
( fab )</pre>      <p>then run it in node:</p>          <pre>$ node fab/lib/node.js fab/examples/hello.js -p 4011</pre>      <p>       and hit <code>http://localhost:4011/</code>.     </p>          <p>       You can also use (fab) as a standard CommonJS library like this:     </p>      <pre class="sh_javascript">fab = require( "../../fab" );
http = require( "http" );

http.createServer(

  ( fab )
    ( "/hello", "hello!" )
  ( fab )

).listen( 4011 );</pre>      <p>then run it like this:</p>          <pre>$ node fab/examples/hello2.js</pre>          <h3>Table of Contents</h3>          <ul>       <li><a href="#chainfindbind">Using chaining to find and bind</a></li>       <li><a href="#installing">Installing (fab)</a></li>       <li><a href="#gettingstarted">Getting started</a></li>       <li><a href="#addingpaths">Adding paths</a></li>       <li><a href="#nestedpaths">Nesting paths</a></li>       <li><a href="#regexpaths">Matching paths with regular expressions</a></li>       <li><a href="#extendingcontexts">Extending contexts</a></li>       <li><a href="#handlingstatuses">Handling error and other status codes</a></li>       <li><a href="#defininghandlers">Defining handler functions</a></li>       <li><a href="#asyncandstreaming">Returning asynchronous and streaming responses</a></li>       <li><a href="#streamingrequests">Handling streaming requests</a></li>       <li><a href="#usingmiddleware">Using middleware</a></li>       <li><a href="#whatsnext">What's next</a></li>       <li><a href="#feedback">Feedback</a></li>       <li><a href="#license">License</a></li>     </ul>              <h3 id="chainfindbind">Using chaining to find and bind</h3>          <p>       Just like you would use <a href="http://jquery.com">jQuery</a> to <em>find</em> nodes in the DOM and <em>bind</em> event handlers to them, you can use (fab) to <em>find</em> parts of your site, and <em>bind</em> request handlers to them.     </p>      <p>       And like jQuery, (fab) works by chaining. This means that instead of saving traversal targets locally, you can chain them together to keep things less verbose. But the difference is that (fab) uses one overloaded function instead of a collection of methods, so instead of chaining methods, you're chaining functions. (fab) doesn't expose any of it's own methods; instead, it lets you focus on your own:     </p>          <pre class="sh_javascript">( fab )
  ( "/time", function() {
    return "the time is " + (new Date).toTimeString();
  })
  ( "/date", function() {
    return "the date is " + (new Date).toDateString();
  })
( fab )</pre>          <p>       (fab)'s brevity may look unorthodox, but it's perfectly valid javascript, without the need for pre-compilation or <code>with</code> scoping magic.     </p>      <h3 id="installing">Installing (fab)</h3>          <p>       Once you've installed <a href="http://nodejs.org">node.js</a>, download (fab) <a href="http://github.com/jed/fab/archives/master">here</a>, or clone it using git:     </p>      <pre>git clone git://github.com/jed/fab.git</pre>          <p>       All of the following examples assume you're in the directory that contains the (fab) repository.     </p>      <h3 id="gettingstarted">Getting started</h3>          <p>       To get a better understanding of how (fab) works, let's start with the bare minimum. Here's the smallest possible (fab) app:     </p>      <pre class="sh_javascript">( fab )( fab )</pre>          <p>       Yep, that's it. This returns a listener: a function that receives HTTP requests and returns HTTP responses. But since we haven't defined any paths, it'll just respond to everything with a 404.     </p>          <h3 id="addingpaths">Adding paths</h3>          <p>       So now let's add a path, to get our original hello world application:     </p>      <pre class="sh_javascript">( fab )
  ( "/hello", "hello!" )
( fab )</pre>          <p>       This will return <code>hello!</code> for any <code>GET</code> request on the <code>/hello</code> path, and a 404 for anything else. The string <code>hello world</code> is just a shortcut, and is automatically turned into a function, so the following is identical:     </p>      <pre class="sh_javascript">( fab )
  ( "/hello", function(){ return "hello!" } )
( fab )</pre>          <p>       Let's add another path:     </p>      <pre class="sh_javascript">( fab )
  ( "/hello", "hello!" )
  ( "/hello/world", "hello world!" )
( fab )</pre>          <p>       Now our app responds to both paths.     </p>          <h3 id="nestedpaths">Nesting paths</h3>          <p>       For paths with a common prefix, like the two above, we can take advantage of (fab)'s hierarchy; like folders in a filesystem, (fab) paths can contain other paths. So this is identical:     </p>      <pre class="sh_javascript">( fab )
  ( "/hello" )
    [ "GET" ]( "hello!" )
    ( "/world", "hello world!" )
  ()
( fab )</pre>          <p>       We've added three new ideas here:     </p>          <ol>       <li>         When a single string (<code>/hello</code> in this case) is passed as an argument, it returns a new subpath context.       </li>       <li>         <code>[ "GET" ]</code> can be used to bind to <code>GET</code> requests on the current context. All other common http methods (<code>HEAD</code>, <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>OPTIONS</code>, and <code>CONNECT</code>) are also available, as well as the catch-all <code>*</code>. Since <code>[ "GET" ]</code> is just a reference to the <code>GET</code> method, we can also substitute it with the more conventional <code>.GET</code>.       </li>       <li>         The empty call <code>()</code> returns the previous context, which in this case is the root of our app.       </li>     </ol>          <h3 id="regexpaths">Matching paths with regular expressions</h3>          <p>       Regular expressions can also be used instead of strings, for binding handlers on matching paths:     </p>      <pre class="sh_javascript">( fab )
  ( "/hello" )
    [ "GET" ]( "hello!" )
    ( /\/(\w+)/, "hello you!" )
  ()
( fab )</pre>          <p>       The results of substring matches are available to function handlers too, through the <code>capture</code> object on <code>this</code> in the handler. This allows us to return dynamic results:     </p>      <pre class="sh_javascript">( fab )
  ( "/hello" )
    [ "GET" ]( "hello!" )
    ( /\/(\w+)/, function(){
      return "hello, " + this.url.capture[ 0 ] + "!"
    })
  ()
( fab )</pre>          <p>       so that a <code>GET</code> request to <code>/hello/jed</code> would return <code>hello, jed!</code>.     </p>      <h3 id="extendingcontexts">Extending contexts</h3>          <p>       (fab) lets us build apps separately in a modular fashion, and then merge them together. This means that we can do this:     </p>      <pre class="sh_javascript">updateGoodbye =
  ( fab )
    ( "/goodbye", "i replaced the existing handler" )
  ()

( fab )
  ( "/hello", "hello!" )
  ( "/goodbye", "goodbye, i'm going to get replaced!" )
  ( updateGoodbye )
( fab )</pre>          <h3 id="handlingstatuses">Handling error and other status codes</h3>          <p>       (fab) also lets us define how we want status codes to be handled, for each level of our app:     </p>      <pre class="sh_javascript">( fab )
  ( "/hello" )
    [ "GET" ]( "hello!" )
    ( /\/([a-z]+)/, function(){
      return "hello, " + this.url.capture[ 0 ] + "!"
    })
    [ 404 ]( "sorry, only lowercase names are supported." )
  ()
  [ 404 ]( "sorry, only /hello paths are valid." )
( fab )</pre>          <p>       This allows us to define more meaningful status handlers that are local to each path. When a status is thrown, (fab) will walk up the hierarchy and call the first status handler it finds.     <p>          <h3 id="defininghandlers">Defining handler functions</h3>          <p>       Since returning static strings isn't very useful, let's talk about function handlers. Here's what every handler has available for every request:     </p>          <ul>       <li><code>this.method</code>: the HTTP method for the request</li>       <li><code>this.headers</code>: the HTTP headers for the request</li>       <li><code>this.url</code>: the request url, parsed into components, like <code>query</code> and <code>capture</code></li>     </ul>          <p>       We can use this information to return any of the following:     </p>          <ul>       <li>         a number (such as <code>404</code>), which will invoke the appropriate status handler,       </li>       <li>         a JSGI response such as the following, which sets the status to 200, sets the <code>Content-Length</code> header to <code>6</code> and the <code>Content-Type</code> header to <code>text/plain</code>, sends a body with <code>hello!</code>, and finishes the response.       </li>     </ul>      <pre class="sh_javascript">( fab )
  ( "/hello", function() {
    return {
      status: 200,
      headers: {
        "Content-Length": 6,
        "Content-Type": "text/plain"
      },
      body: "hello!"
    };
  })
( fab )</pre>          <p>       Note that partial JSGI responses (such as <code>{ status: 204 }</code> or <code>{ headers: "location": "http://nodejs.org" }</code>) are also allowed. Anything that does not conform to a partial JSGI object (any object with no keys or keys other than <code>status</code>, <code>headers</code>, or <code>body</code>) is treated as a response body, so that <code>"hello!"</code> is converted to the partial JSGI response <code>{ body: "hello!" }</code>.     </p>            <h3 id="asyncandstreaming">Returning asynchronous and streaming responses</h3>          <p>       In all the examples above, we've used a static string, or a function that returns the response. But in a truly async app, we can't return the response right away; we might be waiting for some database results, or a remote call. Or we might need to wait until the body of a <code>POST</code> response is fully sent before responding.     </p>          <p>       That's no problem for (fab). Every function handler is actually passed one argument: a <code>respond</code> function. So we can do this:     </p>      <p>       (You can also have your function receive two arguments: <code>request</code> and <code>respond</code>: in this case, the <code>request</code> parameter is set to <code>this</code> so that you don't need any <code>var self = this</code> hackery for nested functions.)     </p>      <pre class="sh_javascript">( fab )
  ( "/hello", function( respond ) {
    setTimeout( function() {
      respond( "hello, sorry to make you wait!", null );
    }, 2000 );
  })
( fab )</pre>          <p>       Any arguments passed to this function can be sent as a response whenever the payload is ready, and <code>null</code> is used to finish the response. in fact, any value returned in the previous example is converted into a call to the <code>respond</code> function, so that these are all equivalent:     </p>      <pre class="sh_javascript">( fab )
  ( "/hello1", {
    status: 200,
    headers: { "Content-Length": 6 },
    body: "hello!"
  })

  ( "/hello2", function() {
    return {
      status: 200,
      headers: { "Content-Length": 6 },
      body: "hello!"
    };
  })

  ( "/hello3", function() {
    respond({
      status: 200,
      headers: { "Content-Length": 6 },
      body: "hello!"
    }, null );
  })

  ( "/hello4", function() {
    respond( { status: 200 } );
    respond( { headers: { "Content-Length": 6 } } );
    respond( { body: "hello!" } );
    respond( null );
  })
( fab )</pre>          <p>       This allows us to take advantage of the intutive use of <code>return</code>, without requiring synchronicity. keep in mind that if the handler function doesn't return anything, the connection will remain open until <code>respond( null )</code> is called.     </p>          <h3 id="streamingrequests">Handling streaming requests</h3>          <p>       So far we've returned numbers, objects, and strings to assemble responses, but there's one more thing we can return: a function. This function becomes a listener for subsequent request events.     </p>      <pre class="sh_javascript">( fab )
  ( "/hello" )
    [ "POST" ]( function( respond ) {
      var buffer = "";
      return function( data ) {
        if ( data !== null ) buffer += data;
        else respond( buffer.length + " characters sent", null );
      }
    })
  ()
( fab )</pre>          <p>       Just like the <code>respond</code> function, the listener function takes one argument: the data payload. if the payload is <code>null</code>, the request is finished and we can return the response.     </p>          <h3 id="usingmiddleware">Using middleware</h3>          <p>       (fab) is easy to extend with your own functions:     </p>      <pre class="sh_javascript">function addContentLength( handler ) {
  return function( respond ) {
    handler.call( this, function( data ) {
      if ( data && typeof data.body === "string" ) {
        var length = process._byteLength( data.body );

        data.headers = data.headers || {};
        data.headers[ "Content-Length" ] = length;
      }
          
      respond( data );
    })
  };
}

( fab )
  ( addContentLength )
  ( "/hello", {
    status: 200,
    headers: { "Content-Type": "text/plain" },
    body: "hello!"
  })
( fab )</pre>          <p>       Any context can be wrapped with a "middleware" wrapper function. This function takes a single argument, the current handler, and returns another handler, which replaces the current handler on the current context.     </p>      <p>       In the above example, the response body is buffered, and then a <code>Content-Length</code> header is added once the response is finished.     </p>          <p>       More documentation on this is forthcoming.     </p>          <h3 id="whatsnext">What's next</h3>      <p>       Here are some things i think would be nice to add for future versions of (fab):     </p>          <ul>       <li>         Middleware examples, including basic authentication, header generation for etags, content length, and other basic niceties.       </li>       <li>         Support for other platforms, most importantly browser environments. This would let you run the same (fab) code on both client and server.       </li>     </ul>          <h3 id="feedback">Feedback</h3>          <p>       Feel free to <a href="http://github.com/jed/fab/issues">add an issue</a> if you find a bug, or fork as you'd like and send me a pull request. You can also find me sometimes in #node.js on freenode, or on <a href="http://twitter.com/jedschmidt">@jedschmidt</a> on twitter.     </p>          <h3 id="license">License</h3>          <p>       Copyright (c) 2009 Jed Schmidt (<a href="http://jedschmidt.com">http://jedschmidt.com</a>)     </p>          <p>       Permission is hereby granted, free of charge, to any person obtaining       a copy of this software and associated documentation files (the       'Software'), to deal in the Software without restriction, including       without limitation the rights to use, copy, modify, merge, publish,       distribute, sublicense, and/or sell copies of the Software, and to       permit persons to whom the Software is furnished to do so, subject to       the following conditions:     </p>          <p>       The above copyright notice and this permission notice shall be       included in all copies or substantial portions of the Software.     </p>          <p>       THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.       IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY       CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,       TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE       SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.     </p>   </div> </body> </html>